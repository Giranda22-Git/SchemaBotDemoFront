# Документация по созданию ботов с помощью json схем
## Для проекта версии v0.4
### Вводная информация
#####Для начало бот строится из разных узлов/node
Сейчас существуют такие узлы:
question - испльзуется для того что бы задать пользователю вопрос
select - используется для того что бы спросить что то у пользователя с заранее заданными вариантами ответа / кнопками
message - просто сообщение ничего лишнего
setting - глобальные настройки бота
screenplay - сценарий обьединяющий все узлы в единый сценарий
delaydScreenplay - такой жее сценарий как и предыдущий но у него все узлы запускаются по таймеру
Это было краткое описание всех узлов действий
далее по подробнее
### Модули
Перед тем как разбираться с каждым узлом по отдельности нужно разобрать все модули которые поддерживают узлы

Модули - это стандартизированные для всех узлов функции как либо действий, PS: пока что не очень стандартизированные

#### Requests
Первый модуль это requests - это модуль отвечающий за http запросы
И так вот его тело:
```json
    "requests": [
      {
        "url": String,  url адрес вместе с endpoint'ами сервера куда нужно отправить запрос
        "method": "post",  метод запроса
        "inData": true/false  не обязательный параметр по умолчанию true, если true то все параметры body будут отправлены в обертке data
        "postData": {  сюда можно запихать все данные которые вы хотите отправить, данные хранятся в оболочке пользователя но об этом по позже
          "name": true/false  просто пишем какой параметр отправить со значение true, или false, если не хотим но это не обязательно
        },
        setResponseData: {
          "id": true/false  созранение response данных если поле == true, если какой то параметр не всегда приходит не страшно он его просто не сохранит никаких ошибок не будет
        }
      }
    ]
```
Как вы видите requests это массив, что позволяет нам отправить сразу много разных http запросов.
Так же важное уточнение request отправляется в конце жизненного цикла узла.

#### buttons
модуль buttons - очень сложный модуль, отвечает за отправку нужных вам кнопок
его тело:
```json
"buttons": [  Массив!
  {
    "text": String,  Просто текст кнопки
    "callBackData": String,  этот параметр пока что является настоящей головной болью, вам нужно просто как то его назвать неважно как но длинна должна быть не больше 25 символов и название должно быть уникально!!, и еще можно в конце добавить (<StringData>) если указанно и тип кнопки является field то при нажатии на кнопку ваши <StringData> сохранится в данные пользователя с ключом field
    "customFunction": {
      "type": String  кастомная функция которая сработает при нажатии на кнопку, пока что работает очень сыро возможны баги, так что пока что на свой страх и риск
    },
    "buttonType": {
      "type": String  тип кнопки, на каждый тип кнопки отдельное поле, подробнее читать ниже
    },
    "field": {
      "type": String
    },
    "nextNode": {
      "type": String
    },
    "addNextNode": {
      "type": Object
    },
    "replaceNextNode": {
      "type": Object
    }
  }
]
```
Типы кнопок для параметра buttonType:
field - нужно заполнить название поля тогда при нажатии на кнопку <StringData> из параметра callBackData сохранится в userData с ключом field

next - нужно заполнить поле nextNode оно принимает Строку с названием Сценария на который нужно переключиться при нажатии на эту кнопку

addNextNode - с одноименным полем которое нужно заполнить оно принимает Обьект с описанием узла действия который встанет в самое начало сценария и перейдет к нему при этом текущий узел будет сразу после него

skip - тут все просто даже заполнять никаких параметов больше не нужно, он просто скипает текущий узел и идет дальше по сценарию

replaceNextNode - нужно заполнить одноименное поле оно принимает Обьект с описанием узла действия котрый заменит текущий по сценарию узел на нужный вам

#### output
Следующий модуль output - это модуль отвечающий за отправку каких либо данных пользователю по средствам сообщений
вот его тело:
```json
"output": {
  "customFunction": {
    "type": String  кастомная функция для отправки сообщения пока сыро, но работает
  },
  "text": {
    "type": String  текст сообщения
  },
  "imageUrl": {
    "type": String  url картинки для сообщения
  },
  "documents": {
    "location": String  принимает remote/source
    "filename": String  название файла
    "url": String  url документа, только если location == remote
  }
  "buttons": []  Модуль buttons
}
```

#### multiple
модуль multiple - это модуль отвечающий за принятие больше одного ответа, рработает только в узле question
его тело:
```json
"multiple": {
  "minCount": Number,  минимальное количество ответов
  "maxCount": Number,  максимальное количество ответов
  "output":  модуль output который будет срабатывать после каждого данного пользователем ответа, здесь он поддерживает только три buttonType: field, replaceNextNode, и next
}
все ответы будут записаны в поле указанное в поле field которое задается напрямую узлу question
так же если используется этот модуль то поле field становится Array со всеми ответами пользователя
```

#### ifField
модуль ifField - он определяет что делать если поле field пустое или не пустое, этот модуль пока что работает только для узла question
```json
"ifField": {
  "field": String,  название поля котрое будем проверять
  "isEmpty": {  сработает если поле пустое или несуществует
    "addNodes": [  массив Обьектов с описанием узлов которые нужно сразу после текущего узла
      {
        "screenplayType": String,
        "name": String
      }
    ]
  },
  "isNotEmpty": {  сработает если поле существует и не пустое
    "addNodes": [  массив Обьектов с описанием узлов которые нужно сразу после текущего узла
      {
        "screenplayType": String,
        "name": String
      }
    ]
  }
}
```

#### cleanFields
модуль cleanFields - это простенький модуль
он очистит все поля которые вы укажите
срабатывает при инициализации текущего узла то есть сразу при переключении на узел с этим модулем как и модуль output
тело:
```json
"cleanFields": [String]  Массив строк, с названиями полей которые нужно очистить
```

#### validation
модуль validation - проводит валидацию над полем указанным в узле question, работает только в связке с узлом question
его тело:
```json
"validation": {
  "enableExtensions": [String],  нужен только если questionType == любой файл, это массив с названиями расширений файлов которые разрешено отправлять боту, например [ 'png', 'jpeg', 'docx' и тд ]
  "disableExtensions": [String],  тоже самое что и предыдущий пареметр только наоборот запрещает введенные расширения файлов
  "regExp": String,  регулярное выражение над текстом
  "ignoreSubStr": [String],  вырезает подстроку из итогового ответа пользователя, срабатывает раньше регулярного выражения
  "minLength": Number,  минимальная длинна текста ответа пользователя
  "maxLength": Number,  максимальная длинна теекста ответа пользоваателя
  "output": модуль output  модуль output срабатывает если ответ не прошел валидацию, здесь он не поддрживает кнопки
}
```

#### destroy
модуль destroy - самый простой, удаляет сообщение узла в самом конце жизненого цикла этого узла если значение true, по дефолту false
```json
"destroy": Boolean
```
И на этом мы закончили с модулями.


### Узлы
#### message
тело узла message:
```json
"name": String,  обязательное поле у каждого узла, должно быть уникально для каждого
"customFunction": String,  как всгда работает но сыро
"requests": модуль requests,  если не знате что это такое читайте выше
"output": модуль output  без кнопок
```

#### question
тело узла question:
```json
"name": String  обязательное поле у каждого узла, должно быть уникально для каждого
"questionType": String  тип вопроса, есть 3 типа: text, photo, document, можно указать сразу несколько типов в этом случае может принимать все указанные типы
"field": String,  название поля в которе будет сохранен ответ пользователя
"cleanFields": модуль cleanFields
"ifField": модуль ifField
"requests": модуль requests
"multiple": модуль multiple
"validation": модуль validation
"output": модуль output  пока что не поддерживает документы в этом узле
```


#### select
тело узла select:
```json
"name": String  обязательное поле у каждого узла, должно быть уникально для каждого
"destroy": модуль destroy
"output": модуль output
```

#### screenplay
тело узла screenplay:
```json
"name": String  обязательное поле у каждого узла, должно быть уникально для каждого, для сценария который должен сработать при первом обращении пользователя или при /start - name должен быть main
"screenplay": [  сценарий этого узла
  {  Обьект описания узла
    "screenplayType": String,  тип узла который вы хотите добавить в этот сценарий например question или message
    "name": String  название узла
  }
]
```

#### delaydScreenplay
тело узла delaydScreenplay:
```json
"name": String  обязательное поле у каждого узла, должно быть уникально для каждого
"screenplay": [  сценарий этого узла
  {  Обьект описания узла
    "screenplayType": String,  тип узла который вы хотите добавить в этот сценарий
    "name": String  название узла
    "repeat": Number  количество повторений этого узла
    "delay": {  время через которое должен сработать данный узел можете указать несколько параметров сразу например 3дня 5 часов и 2 секунды или просто 2 минуты
      "day": Number,
      "hour": Number,
      "minute": Number,
      "second": Number
    }
  }
]
```

#### setting
тело узла setting
```json
"name": String  обязательное поле у каждого узла, должно быть уникально для каждого, но также первый самый главный setting должен обязательно называться main
"telegramBotToken": String  токен телеграм бота
"logs": {  настройки логов бота
  "allLogs": true/false  пока что он работает только так грубо так сказать либо все логи либо ни какие, в дальнейшем нужно добавить возможность более тонкой настройки,
  "outputId": String,  telegramId пользователя или группы/канала в который будут отправляться логи, если это telegramId группы/канала то нужно перед этим добавить бота в эту группу/канал, а если пользователя, то этот пользователь должен хотя бы раз отпрраить сообщение боту для его регистрации
}
```